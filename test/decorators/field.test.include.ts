/* eslint-disable mocha/no-async-describe */
/* eslint-disable no-new-func */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/class-name-casing */
import { expect } from 'chai';
import {
    document, Registry, field, identifier,
} from '../../src';

describe('@field', function () {

    it('expect @field to not override @document collection name', async function () {

        expect(function (): string {
                @document({ collection: 'coll1' })
            class ClassWithField {
                    @field()
                    name: string;
                }
                return Registry.getCollectionName(ClassWithField);
        }()).to.equal('coll1');
    });

    it('expect @field to imply @document on its class', async function () {

        expect(function (): string {
            class ClassWithFieldAndNoCollection {
                    @field()
                    name: string;
            }
            return Registry.getCollectionName(ClassWithFieldAndNoCollection);
        }()).to.equal('classWithFieldAndNoCollections');
    });

    it('expect manual property registration to pass', async function () {

        expect((function () {
            class ManualFieldRegistration {
                    name: string;
            }
            const obj: ManualFieldRegistration = new ManualFieldRegistration();
            Registry.addField(obj, 'name');
            return Registry.getField(ManualFieldRegistration, 'name')[1];
        }())).to.equal('name');
    });

    it('expect autogenerated field name to pass', async function () {

        expect(function (): string {
            class AutoFieldName {
                    @field()
                    field: string;
            }
            return Registry.getField(AutoFieldName, 'field')[1];
        }()).to.equal('field');
    });

    it('expect autogenerated field type to pass', async function () {

        expect(function (): string {
            class AutoFieldType {
                    @field()
                    field: string;
            }
            return Registry.getField(AutoFieldType, 'field')[2].options.type.name;
        }()).to.equal('String');
    });

    it('expect manual field name to pass', async function () {

        expect(function (): string {
            class ManualFieldName {
                    @field({ name: '__name' })
                    name: string;
            }
            return Registry.getField(ManualFieldName, 'name')[1];
        }()).to.equal('__name');
    });

    it('expect getting info on property to pass', async function () {

        expect((function () {
            @document()
            class PropetyNameCheck {
                @field()
                name: string;
            }
            return Registry.getProperty(PropetyNameCheck, 'name');
        }()).name).to.equal('name');
    });

    it('expect getting info on property of a non-existent class to fail', async function () {

        expect(function () {
            class PropetyNameCheck {
                name: string;
            }
            return Registry.getProperty(PropetyNameCheck, 'name');
        }()).to.be.undefined;
    });

    it('expect getting info on field of a non-existent class to fail', async function () {

        expect(function () {
            class FieldNameWrong1 {
                name: string;
            }

            // class FieldNameWrong2 {
            //     @field()
            //     name: string;
            // }
            return Registry.getField(FieldNameWrong1, 'name');
        }()).to.deep.equal([undefined, undefined, undefined]);
    });

    it('expect getting info on non-existent field to fail', async function () {

        expect(function () {
            class FieldNameWrong {
                    @field({ name: '__name' })
                    name: string;

                    wrong: string;
            }
            return Registry.getField(FieldNameWrong, 'wrong');
        }()).to.deep.equal([undefined, undefined, undefined]);
    });

    it('expect multiple decorators on same property to override field name', async function () {

        expect(function (): string {
            class MultipleFieldNames {
                    @field({ name: '__name2' })
                    @field({ name: '__name3' })
                    name: string;
            }
            return Registry.getField(MultipleFieldNames, 'name')[1];
        }()).to.equal('__name2');
    });

    it('expect multiple decorators on same property with same field name to do nothing', async function () {

        expect(function (): string {
            class MultipleSameFieldNames {
                    @field({ name: '__name2' })
                    @field({ name: '__name2' })
                    name: string;
            }
            return Registry.getField(MultipleSameFieldNames, 'name')[1];
        }()).to.equal('__name2');
    });

    it('expect multiple decorators on same property to override field type', async function () {

        expect(function (): string {
            class MultipleFieldTypes {
                    @field({ type: Number })
                    @field({ type: Boolean })
                    name: string;
            }
            return Registry.getField(MultipleFieldTypes, 'name')[2].options.type.name;
        }()).to.equal('Boolean');
    });

    it('expect multiple decorators on same property to coalesce options', async function () {

        const [, fieldName, prop] = (function () {
            class MultipleFieldOptions {
                @field({ name: 'field' })
                @field({ type: Number })
                field1: boolean;
            }
            return Registry.getField(MultipleFieldOptions, 'field1');
        }());
        expect(fieldName).to.equal('field');
        expect(prop.options.type.name).to.equal('Number');
    });
});
